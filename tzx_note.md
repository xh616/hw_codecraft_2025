要点
- 初始化时，告知了每1800个时间周期内每个标签的删除、读写的总对象块
- 写入和删除操作无需移动磁头，立刻生效
- 读操作需要移动磁头，消耗token
- 副本数量固定为3，需要保证同一个副本的对象块写在同一块盘上，不同副本的对象块写在不同的盘上。
- 读取操作可以拼接


实现思路：
- 需要解决对象的读、写、删除。同时规划好对象块的分布、磁头的移动。
- 需要维护什么？
  - 每个磁盘：磁头位置；
    - jump操作很贵，如果当前磁头位置和目标位置相差太远，需要考虑是否需要jump
  - 每个对象块：副本的位置；读取请求队列
  - 每个读取请求：开始时间，读哪个对象，读那几个对象块（磁盘+位置，最多5个块），完成情况
  - 写入操作：挑选3个磁盘，每个磁盘至多写入5个对象块
    - 每个磁盘内对象块连续？这样读操作不太好拼接
    - 将对象块分成3份（`[12345] -> [123][4][5]`）,尽可能分散。目的是读操作可以拼接 & 多线程
    - 具体：找磁头后G个位置空闲块最多的磁盘，写入对象块。一个在头部，一个在中部，一个在尾部
  - 删除操作：标记对象块为删除状态，不再读取。o(1)维护
  - 读取操作：本质是操作磁头，同时维护读取请求。同时处理多个磁头。
  - 先for，再改造成并行


---

优化点：
- 优化思路：
  - 定磁头移动逻辑
  - 基于磁头移动逻辑，确定insert & 生成子查询逻辑
- size越大的对象（对象块越多），得分越高
- 105个时间片之后，这个查询没有意义了
- 思路：查询请求的优先级，优先处理size大的对象块
- Tag：
  - 每1800个时间片为一组，给出每个标签的对象块的删除、写入、读取总数
  - 如何使用Tag？相同Tag放一块？
  - 如果一组中，某个标签的对象块的写入、读取操作很多。如何处理？
  - 如果写入大读取小？
  - 如果读取大写入小？
  - 如果删除大？
- 还有哪些？

默认实现：所有读请求基本上都完成了，但是没考虑优先级